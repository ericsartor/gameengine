- refactor todo
    - loading script should be generated by tooling, and each class should define its own static loading method that returns an instance, see Sheet for example
    - loading should happen in order of Sheets, then Animations, then Pawns, then Stages
    - tooling should generate code that creates Sheet, Animation and Pawn instances (or maybe subclasses?) so intellisense works



- engine
    - add abstraction over line and rectangle drawing functions that consider current game scale and use grid positions rather than pixel
    - stages should be drawn by layer, left to right, top to bottom lowest layer to highest layer, to ensure z-indexing works as expected
    - pawns should be also be drawn top to bottom
    - Sheet metadata should store which sprites are hitbox by default, and the tooling would know to place the hitbox when using the sprite
    - hitbox "groups" so that certain hitboxes can ignore each other
    - figure out how to organize class methods that are only to be used by the engine separately from public methods to be used by the game logic
    - dedupe pawn loading if multiple pawns are to use the same config
    - Pawn "animation sets", basically matched sets of animations with the same name but different sprites, that can be switched between
        - this would be for things like a "runing" vs "walking" animation set that would be toggled on press/release of "shift" for example
    - Pawns should be able to be chroma keyed dynamically at any time, which would just update the canvas
        - need to start storing original canvas so we can chroma key it if necessary
    - Game should have a "setup" function that runs after "start" has completed and eveything has been loaded but before first logic loop
    - Pawn registering should hold a canonical default version of that pawn, then make you "create" pawns from that default instance`
    - Inputs should allow for multiple identifiers so that rebinding isnt always necessary between keyboard and controller, etc
    - animations within pawns should have their own origin, pawns themselves do not need an origin
    - pawn should be able to be just a static image with no animations
    - pawn map should throw on conflicting name
    - stage metadata should support multiple sheets, the cell layers should be three numbers, [sheetIndex, x, y]
    - stage doesnt need "layers", only three nested arrays, [column, cell, things to draw]
    - smooth camera movements (go from here to there over this time)
    - "nudge" hitboxes that, when collided with, convert the movement they are preventing into a different axis so that you slide along them without explicitly moving in that direction
    - add some kind of "pawn outline" system where you can specify yes/no and color of the outline, could be used for selection, highlighting, blinking, etc
        - might have to expand sprite sheets to fit outlines or even other elements in the future
        - in that case, you'd have to chop up spritesheets according to their grid size, then expand every single sprite and track its origin
        - this would mean spritesheets can ONLY EVER have sprites that are the same grid size, whether that's 2x1, 1x1, 4x3, etc
            - the engine/tooling would have to manage this such that the tooling might let you specify different sized sprites frmo one source image, but they'd get written into storage on spritesheets with the same grid size

- tooling

  - separate code into "tools" and "lib" folders
  - tools
    - local API server takes request to do things like manage game assets and metadata
      - POST /new-game
        - √ takes full game metadata in body
        - √ uses `vite` to create a new project with the provided name with TypeScript as a sibling of the `engine` folder
        - √ writes a file called `game-config.json` that keeps details about the game to be used by tooling, like name, grid size, etc
        - initializes the `main.ts` with some boilerplate code that:
          - √ instantiates a game with specified gridsize
          - registers a test pawn with movement controls via logic function
          - registers a test stage
          - registers some loading callbacks that just print to the console
          - √ starts the game
      - GET /game/:gameName/inventory
        - gets a JSON inventory of all sheets/aniamtions/pawns/stages (images must be downloaded separately)
      - √ GET /game/:gameName/metadata
        - √ gets the game.json file in the game root
      - √ MOVE /game/:gameName/files/move?file=...&to=...
        - √ takes a "file" (with extension) and "to" (with extension) in the URL query
        - √ moves the specified file (and associated image if sheet) to the new location
      - √ DELETE /game/:gameName/files/delete?file=...
        - √ takes a "file" (with extension) in the URL query
        - √ deletes the file (and associated image if sheet)
      - √ POST /game/:gameName/metadata
        - √ takes full game metadata in body
        - √ creates/updates the game.json file in the game root
      - √ POST /game/:gameName/sheet/metadata
        - √ takes full sheet metadata in body
        - √ stores the metadata at the specified location as a .sheet
      - √ POST /game/:gameName/sheet/image?location=...
        - √ takes image file in body
        - √ takes "location" in query
        - √ stores the image at the specified location as a .png
      - POST /game/:gameName/animation/metadata
        - takes full animation metadata in body
        - stores the metadata at the specified location as a .animation
      - POST /game/:gameName/pawn/metadata
        - takes full pawn metadata in body
        - stores the metadata at the specified location as a .pawn
      - POST /game/:gameName/stage/metadata
        - takes full stage metadata in body
        - stores the metadata at the specified location as a .stage
    - spritesheet tool
      - should have some kind of support fpor the chroma keying feature even if you aren't drawing in it directly, you should be able to preview chroma keying to make sure it works
    - pawn tool
      - uses game grid size to split up sprite sheets
      - lets you create animations/animation sets from the sprites sheets with offsets and preview them in engine
      - lets you set default chroma color if necessary
      - lets you add hitboxes
    - stage tool
      - uses game grid size to split up sprite sheets
      - lets you create stages from the sprites sheets with offsets and preview them in engine
      - lets you set default chroma color if necessary
      - lets you add hitboxes (can be bigger than one grid square)
      - lets you add "triggers" that game be referenced in game by name rather than location (so you can interact with stage elements rather than pawns)
      - lets you place pawns with custom names that can be referenced in game (set up NPCs, etc)

- docs
  - inputs
    - getting inputs by name
    - checking input buffer
    - input handlers
  - pawns
    - regisering/loading/creating
    - paths
    - animations
    - movement
    - hitboxes
  - logic/drawing
    - registering logic functions
    - register custom draw functions
  - loading
    - how it works
    - loading progress and complete handlers
  - stages
    - defaulting
    - loading
    - referencing triggers and pawns
